{"version":3,"sources":["../../src/useQueries.ts"],"sourcesContent":["import { QueriesObserver } from '@tanstack/query-core'\nimport {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  readonly,\n  shallowReadonly,\n  shallowRef,\n  unref,\n  watch,\n} from 'vue-demi'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  DefaultError,\n  DefinedQueryObserverResult,\n  QueriesObserverOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './useQuery'\nimport type { QueryClient } from './queryClient'\nimport type { DeepUnwrapRef, MaybeRefDeep } from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function does not have a parameter\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: if UseQueryOptions are already being sent through, then just return T\n  T extends UseQueryOptions\n    ? DeepUnwrapRef<T>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n      T extends {\n          queryFnData: infer TQueryFnData\n          error?: infer TError\n          data: infer TData\n        }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n      : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n        : T extends { data: infer TData; error?: infer TError }\n          ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n          : // Part 3: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n            T extends [infer TQueryFnData, infer TError, infer TData]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n            : T extends [infer TQueryFnData, infer TError]\n              ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n              : T extends [infer TQueryFnData]\n                ? UseQueryOptionsForUseQueries<TQueryFnData>\n                : // Part 4: responsible for inferring and enforcing type if no explicit parameter was provided\n                  T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                        | SkipTokenForUseQueries\n                      select?: (data: any) => infer TData\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryOptionsForUseQueries<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError,\n                      unknown extends TData ? TQueryFnData : TData,\n                      TQueryKey\n                    >\n                  : T extends {\n                        queryFn?:\n                          | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                          | SkipTokenForUseQueries\n                        throwOnError?: ThrowOnError<any, infer TError, any, any>\n                      }\n                    ? UseQueryOptionsForUseQueries<\n                        TQueryFnData,\n                        TError,\n                        TQueryFnData,\n                        TQueryKey\n                      >\n                    : // Fallback\n                      UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedQueryObserverResult rather than QueryObserverResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? QueryObserverResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedQueryObserverResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? QueryObserverResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedQueryObserverResult<TData, TError>\n            : QueryObserverResult<TData, TError>\n        : QueryObserverResult<TData, TError>\n  : QueryObserverResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: if using UseQueryOptions then the types are already set\n  T extends UseQueryOptions<\n    infer TQueryFnData,\n    infer TError,\n    infer TData,\n    any,\n    any\n  >\n    ? GetDefinedOrUndefinedQueryResult<\n        T,\n        undefined extends TData ? TQueryFnData : TData,\n        unknown extends TError ? DefaultError : TError\n      >\n    : // Part 2: responsible for mapping explicit type parameter to function result, if object\n      T extends { queryFnData: any; error?: infer TError; data: infer TData }\n      ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n      : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n        : T extends { data: infer TData; error?: infer TError }\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : // Part 3: responsible for mapping explicit type parameter to function result, if tuple\n            T extends [any, infer TError, infer TData]\n            ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n            : T extends [infer TQueryFnData, infer TError]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n              : T extends [infer TQueryFnData]\n                ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n                : // Part 4: responsible for mapping inferred type to results, if no explicit parameter was provided\n                  T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, any>\n                        | SkipTokenForUseQueries\n                      select?: (data: any) => infer TData\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? GetDefinedOrUndefinedQueryResult<\n                      T,\n                      unknown extends TData ? TQueryFnData : TData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : T extends {\n                        queryFn?:\n                          | QueryFunction<infer TQueryFnData, any>\n                          | SkipTokenForUseQueries\n                        throwOnError?: ThrowOnError<any, infer TError, any, any>\n                      }\n                    ? GetDefinedOrUndefinedQueryResult<\n                        T,\n                        TQueryFnData,\n                        unknown extends TError ? DefaultError : TError\n                      >\n                    : // Fallback\n                      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? UseQueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<QueryObserverResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? UseQueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : T extends Array<\n              UseQueryOptionsForUseQueries<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n            Array<\n              QueryObserverResult<\n                unknown extends TData ? TQueryFnData : TData,\n                unknown extends TError ? DefaultError : TError\n              >\n            >\n          : // Fallback\n            Array<QueryObserverResult>\n\ntype UseQueriesOptionsArg<T extends Array<any>> = readonly [\n  ...UseQueriesOptions<T>,\n]\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = UseQueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: MaybeRefDeep<UseQueriesOptionsArg<T>>\n    combine?: (result: UseQueriesResults<T>) => TCombinedResult\n    shallow?: boolean\n  },\n  queryClient?: QueryClient,\n): Readonly<Ref<TCombinedResult>> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const defaultedQueries = computed(() => {\n    // Only unref the top level array.\n    const queriesRaw = unref(queries) as ReadonlyArray<any>\n\n    // Unref the rest for each element in the top level array.\n    return queriesRaw.map((queryOptions) => {\n      const clonedOptions = cloneDeepUnref(queryOptions)\n\n      if (typeof clonedOptions.enabled === 'function') {\n        clonedOptions.enabled = queryOptions.enabled()\n      }\n\n      const defaulted = client.defaultQueryOptions(clonedOptions)\n      defaulted._optimisticResults = client.isRestoring.value\n        ? 'isRestoring'\n        : 'optimistic'\n\n      return defaulted\n    })\n  })\n\n  const observer = new QueriesObserver<TCombinedResult>(\n    client,\n    defaultedQueries.value,\n    options as QueriesObserverOptions<TCombinedResult>,\n  )\n  const [, getCombinedResult] = observer.getOptimisticResult(\n    defaultedQueries.value,\n    (options as QueriesObserverOptions<TCombinedResult>).combine,\n  )\n  const state = shallowRef(getCombinedResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  watch(\n    client.isRestoring,\n    (isRestoring) => {\n      if (!isRestoring) {\n        unsubscribe()\n        unsubscribe = observer.subscribe(() => {\n          const [, getCombinedResultRestoring] = observer.getOptimisticResult(\n            defaultedQueries.value,\n            (options as QueriesObserverOptions<TCombinedResult>).combine,\n          )\n          state.value = getCombinedResultRestoring()\n        })\n        // Subscription would not fire for persisted results\n        const [, getCombinedResultPersisted] = observer.getOptimisticResult(\n          defaultedQueries.value,\n          (options as QueriesObserverOptions<TCombinedResult>).combine,\n        )\n        state.value = getCombinedResultPersisted()\n      }\n    },\n    { immediate: true },\n  )\n\n  watch(\n    defaultedQueries,\n    () => {\n      observer.setQueries(\n        defaultedQueries.value,\n        options as QueriesObserverOptions<TCombinedResult>,\n      )\n      const [, getCombinedResultPersisted] = observer.getOptimisticResult(\n        defaultedQueries.value,\n        (options as QueriesObserverOptions<TCombinedResult>).combine,\n      )\n      state.value = getCombinedResultPersisted()\n    },\n    { flush: 'sync' },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return process.env.NODE_ENV === 'production'\n    ? state\n    : options.shallow\n      ? shallowReadonly(state)\n      : (readonly(state) as Readonly<Ref<TCombinedResult>>)\n}\n"],"mappings":";AAAA,SAAS,uBAAuB;AAChC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AA4OxB,SAAS,WAId;AAAA,EACE;AAAA,EACA,GAAG;AACL,GAKA,aACgC;AAChC,MAAI,QAAQ,IAAI,aAAa,eAAe;AAC1C,QAAI,CAAC,gBAAgB,GAAG;AACtB,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,eAAe,eAAe;AAE7C,QAAM,mBAAmB,SAAS,MAAM;AAEtC,UAAM,aAAa,MAAM,OAAO;AAGhC,WAAO,WAAW,IAAI,CAAC,iBAAiB;AACtC,YAAM,gBAAgB,eAAe,YAAY;AAEjD,UAAI,OAAO,cAAc,YAAY,YAAY;AAC/C,sBAAc,UAAU,aAAa,QAAQ;AAAA,MAC/C;AAEA,YAAM,YAAY,OAAO,oBAAoB,aAAa;AAC1D,gBAAU,qBAAqB,OAAO,YAAY,QAC9C,gBACA;AAEJ,aAAO;AAAA,IACT,CAAC;AAAA,EACH,CAAC;AAED,QAAM,WAAW,IAAI;AAAA,IACnB;AAAA,IACA,iBAAiB;AAAA,IACjB;AAAA,EACF;AACA,QAAM,CAAC,EAAE,iBAAiB,IAAI,SAAS;AAAA,IACrC,iBAAiB;AAAA,IAChB,QAAoD;AAAA,EACvD;AACA,QAAM,QAAQ,WAAW,kBAAkB,CAAC;AAE5C,MAAI,cAAc,MAAM;AAAA,EAExB;AAEA;AAAA,IACE,OAAO;AAAA,IACP,CAAC,gBAAgB;AACf,UAAI,CAAC,aAAa;AAChB,oBAAY;AACZ,sBAAc,SAAS,UAAU,MAAM;AACrC,gBAAM,CAAC,EAAE,0BAA0B,IAAI,SAAS;AAAA,YAC9C,iBAAiB;AAAA,YAChB,QAAoD;AAAA,UACvD;AACA,gBAAM,QAAQ,2BAA2B;AAAA,QAC3C,CAAC;AAED,cAAM,CAAC,EAAE,0BAA0B,IAAI,SAAS;AAAA,UAC9C,iBAAiB;AAAA,UAChB,QAAoD;AAAA,QACvD;AACA,cAAM,QAAQ,2BAA2B;AAAA,MAC3C;AAAA,IACF;AAAA,IACA,EAAE,WAAW,KAAK;AAAA,EACpB;AAEA;AAAA,IACE;AAAA,IACA,MAAM;AACJ,eAAS;AAAA,QACP,iBAAiB;AAAA,QACjB;AAAA,MACF;AACA,YAAM,CAAC,EAAE,0BAA0B,IAAI,SAAS;AAAA,QAC9C,iBAAiB;AAAA,QAChB,QAAoD;AAAA,MACvD;AACA,YAAM,QAAQ,2BAA2B;AAAA,IAC3C;AAAA,IACA,EAAE,OAAO,OAAO;AAAA,EAClB;AAEA,iBAAe,MAAM;AACnB,gBAAY;AAAA,EACd,CAAC;AAED,SAAO,QAAQ,IAAI,aAAa,eAC5B,QACA,QAAQ,UACN,gBAAgB,KAAK,IACpB,SAAS,KAAK;AACvB;","names":[]}